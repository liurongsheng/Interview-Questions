什么是闭包，闭包有什么缺点 什么情况下用闭包

闭包就是函数嵌套函数，可以理解为定义在函数内部的函数，本质上闭包是函数内部和外部连接的桥梁，但如果父函数定义的变量没有被子函数引用就不叫闭包
闭包让函数的变量都保存在内存中，内存消耗变大。使用不当会造成内存泄漏。
用途：读取函数内部变量 让变量保存到内存中 设置私有变量和方法

函数重载 以及解析顺序
var m= 1, j = k = 0;
function add(n) {
return n = n+1;
&emsp; } ;
y = add(m);
function add(n) {
return n = n + 3;
} ;
z = add(m);

以上代码都会输出 4，js 中没有函数重载的概念，由于定义了连个相同的函数，所以后面的会覆盖前面的
所以调用 add 结果都是一样的因此真正到执行代码的时候，也就是第一次调用 add(),输出的当然是 4,第二次执行 add()同样输出 4.

js 函数调用时加括号和不加括号的区别.不加括号相当于把函数代码赋给等号左边,加括号是把函数返回值赋给等号左边
var color='green';
var text={
color:'blue',
getColor:function() {
var color='red';
alert(this.color)
}
};
var getColor=text.getColor;
getColor();
text.getColor();
//结果为 green blue
关于 this 指针

直接调用的话 this 指向 window 对象（这里如果在函数内部声明一个 name 也指向的 window 对象）

var name='张三';
function sayname() {
console.log(this.name)
};
sayname();

对象函数调用 this 指向对象本身

    var name='Bob';
    function sayName(){
        console.log(this.name);
    };
    var object={'name':'vicky'};
    object.sayName=sayName;          //sayName没有写成sayName(),表示不是执行函数，而是将sayName的指针赋值给object.sayName
    object.sayName();               //由于对象函数调用方法，this指向对象本身，所以输出:'vicky'
    sayName();                     //由于全局环境调用sayName()等同于window.sayName();输出:'Bob'

构造函数调用 this 指针指向新创建的对象

    function object(name){
        this.name=name;
        console.log(this);      //由于this指向新创建的对象本身，输出：Object { name: "vikcy" }
        console.log(this.name);  //输出:"vicky"
    }
    var myObject=new Object('vicky');  //由于this指向新创建的对象本身

JavaScript 原型 原型链

每个对象都会在其内部初始化一个属性，就是 prototype(原型)，当我们访问一个对象的属性时，
如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype，
于是就这样一直找下去，也就是我们平时所说的原型链的概念。

JavaScript 有几种类型的值？

栈：原始数据类型（Undefined，Null，Boolean，Number、String）
堆：引用数据类型（对象、数组和函数）
两种类型的区别是：存储位置不同；
原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数
据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取
得地址后从堆中获得实体

任何对象转为布尔值，都为得到 true（切记！

常见的浏览器内核
谷歌：-webkit-
火狐：-moz-
ie：-ms-
欧鹏：-o-
qq 浏览器：双内核 -webkit- -ms-

## 节点操作

### 创建节点

- createDocumentFragment() // 创建一个 DOM 片段
- createElement() // 创建一个具体的元素
- createTextNode() // 创建一个文本节点

### 添加、移除、替换、插入

- appendChild() // 添加
- removeChild() // 移除
- replaceChild() // 替换
- insertBefore() // 插入

### 查找

- getElementsByTagName() // 通过标签名称
- getElementsByName() // 通过元素的 Name 属性的值
- getElementById() // 通过元素 Id，唯一性

## 作用域

每个函数都有一个作用域，比如我们创建了一个函数，函数里面又包含了一个函数，那么现在就有三个作用域，这样就形参了一个作用域链
特点： 先在自己的变量范围中查找，如果找不到，就会沿着作用域链往上找
