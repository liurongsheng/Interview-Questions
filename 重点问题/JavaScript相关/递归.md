# 递归

在数学与计算机科学中，是指在函数的定义中使用函数自身的方法

在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数

其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解一般来说，

递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进。当边界条件满足时，递归返回

## 尾递归

尾递归，即在函数尾位置调用自身(或是一个尾调用本身的其他函数等等)，尾递归也是递归的一种特殊情形

尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数

尾递归在普通尾调用的基础上，多出了 2 个特征:

- 在尾部调用的是函数自身
- 可通过优化，使得计算仅占用常量栈空间

在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢边

这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾

对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误

### 尾递归好处

- 减少栈空间占用：尾递归不会在每次递归调用时增加新的栈帧，因此占用的栈空间较少
- 避免栈溢出：对于较大的输入值，普通递归容易导致栈溢出，而尾递归则不会
- 性能优化：一些现代编译器和解释器（如 V8 引擎）会对尾递归进行优化，提高执行效率

// 阶乘普通递归示例

```js
function factorial(n) {
  if (n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
factorial(5); // 120
```

步骤

- factorial(5) 调用 factorial(4) 并等待结果
- factorial(4) 调用 factorial(3) 并等待结果
- factorial(3) 调用 factorial(2) 并等待结果
- factorial(2) 调用 factorial(1) 并等待结果
- factorial(1) 返回 1
- factorial(2) 计算 2 × 1 得到 2
- factorial(3) 计算 3 × 2 得到 6
- factorial(4) 计算 4 × 6 得到 24
- factorial(5) 计算 5 × 24 得到 120

问题

每次递归调用都需要保存当前状态，直到所有递归调用完成。这会占用大量的栈空间，容易导致栈溢出

// 阶乘尾递归示例

```js
function factorial(n, total) {
  if (n === 1) {
    return total;
  }
  return factorial(n - 1, n * total);
}
factorial(5, 1); // 120
```

尾递归通过传递一个累加器（total），将中间结果传递给下一次递归调用。

步骤

- factorial(5, 1) 调用 factorial(4, 5 × 1)
- factorial(4, 5) 调用 factorial(3, 4 × 5)
- factorial(3, 20) 调用 factorial(2, 3 × 20)
- factorial(2, 60) 调用 factorial(1, 2 × 60)
- factorial(1, 120) 返回 120

可以看到，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了尾递归只需要保存一个调用栈，复杂度 O(1)

## 快速判断一个递归函数是否可以改为尾递归

- 检查递归调用的位置：查看递归调用是否出现在函数的最后一步
- 检查是否有后续操作：确认在递归调用之后是否还有其他操作需要执行
- 考虑中间结果：确定是否有中间结果需要在递归调用之间传递

实际操作

- 查看递归调用位置：如果递归调用不在函数的最后一行，或者在递归调用之后还有其他操作，那么需要考虑是否可以重构代码
- 重构代码：尝试将所有计算移到递归调用之前，并将结果作为参数传递给下一次递归调用
- 引入累加器：如果需要累积结果，可以引入一个额外的参数来存储中间结果
