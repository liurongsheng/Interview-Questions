# 闭包

`闭包可以理解成，函数+函数体内可访问的变量总和`

一个函数和对其周围状态(lexicalenvironment，词法环境)的引用捆绑在一起(或者说函数被引用包围)，这样的组合就是闭包(closure)

也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域

在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁

```js
function init() {
  var name = "Mozilla"; // name 是一个被 init 创建的局部变量
  function displayame() {
    // displayName()是内部函数，一个闭包
    alert(name); // 使用了父函数中声明的变量
  }
  displayName(); // 输出 "Mozilla"
}
init();
```

displayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量

## 使用场景

- 柯里化函数，避免频繁调用具有相同参数函数的同时，又能够轻松的重用
- 封装私有变量和方法：保护内部变量和方法不受外部直接访问

任何闭包的使用场景都离不开这两点:

- 创建私有变量
- 延长变量的生命周期

一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，

即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的

## 注意事项

如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响

在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中

原因在于每个对象的创建，方法都会被重新赋值

```js
function MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
  this.getName = function () {
    return this.name;
  };
  this.getMessage = function () {
    return this.message;
  };
}
```

上面的代码，并没有利用到闭包的好处，因此可以避免使用闭包，需要修改如下

```js
function MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype.getName = function () {
  return this.name;
};
KMyObject.prototype.getMessage = function () {
  return this.message;
};
```
