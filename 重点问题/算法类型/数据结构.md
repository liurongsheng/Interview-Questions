# 数据结构

## 对数据结构的理解？有哪些？区别？

- 数组 Array
- 栈 Stack，先进后出
- 队列 Queue，先进先出
- 链表 Linked List，数据和下一个节点的指针
- 树 Tree
- 图 Graph
- 堆 Heap
- 散列表 Hsash Table，也称为哈希表

线性结构有：数组、栈、队列、链表等

非线性结构有：树、图、堆等

### 数组

数组是使用一块连续的内存空间保存数据，这意味着每个元素紧跟着前一个元素，占用一块连续的内存空间

数组支持随机访问，即可以通过索引直接访问数组中的任何一个元素，时间复杂度为 O(1)

在数组中插入或删除元素时，可能需要移动后续的所有元素以保持数组的连续性，这会导致较高的时间复杂度 O(n)

### 栈，先进后出

一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据

`在栈里，新元素都接近栈顶，旧元素都接近栈底。每次加入新的元素和拿走元素都在顶部操作`

先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据

基本数据类型存储在栈中，Number、String、Boolean、Undefined、null、Symbol

### 队列，先进先出

跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作

`队列在尾部添加新元素，并从顶部移除元素`

### 链表，数据和下一个节点的指针

链表中的元素在内存中是分散存储的，每个元素（称为节点）包含数据部分和一个指向下一个节点的指针。节点可以位于内存中的任意位置

链表只能顺序访问，需要从头节点开始，沿着指针逐个访问到目标节点，时间复杂度为 O(n)，其中 n 是链表的长度

链表在插入或删除元素时只需改变相关的指针，不需要移动数据，因此时间复杂度为 O(1)（假设已经找到了插入或删除的位置）

链表也是一种列表，已经设计了数组，为什么还需要链表呢？

JavaScript 中数组的主要问题时，它们被实现成了对象，与其他语言(比如 C++和 Java)的数组相对，效率很低，
如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它

使用条件:

- 链表几乎可以用在任何可以使用一维数组的情况中
- 如果需要随机访问，数组仍然是更好的选择

### 树

树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点

### 图

一种非线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系

### 堆

堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小(或最大)，且根结点的两个子树也是一个堆

引用类型的对象存储于堆中，Object、Array、Function

### 散列表

若结构中存在关键字和 K 相等的记录，则必定在 f(K)的存储位置上，不需比较便可直接取得所查记录

用数组或链表存储数据，如果想要找到其中一个数据，需要从头进行遍历，因为不知道这个数据存储到了数组的哪个位置

## 冒泡排序的理解？如何实现？应用场景？

冒泡排序的名字来源于较小的元素会逐渐“浮”到数列的顶端，就像水中的气泡一样，而较大的元素则会逐渐“沉”到底部

## 快速排序的理解？如何实现？应用场景？

分治法的思想

算法是在冒泡排序的基础上进行改进的一种算法，特点是快、效率高，是处理大数据最快的排序算法之一

通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小

然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列

快速排序是冒泡排序的升级版，最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序

## 算法设计与分析

- 分而治之篇，分解原问题->解决子问题->合并结果解

  - 归并排序
  - 快速排序
  - 最大子数组问题 1
  - 逆序计数问题
  - 次序选择问题

- 动态规划篇，问题结果分析->递推关系建立->自底向上计算->最优方案追踪

  - 0-1 背包问题
  - 最大子数组问题 2
  - 最长公共子序列问题
  - 最长公共子串列问题
  - 最小编辑距离问题
  - 锯条切割问题-
  - 矩阵链乘法问题

- 贪心策略篇，提出贪心策略->证明策略正确性->求解最优解

  - 部分背包问题
  - 霍夫曼编码
  - 活动选择问题
