# http 问题

## 理解 UDP 和 TCP？区别？应用场景？

UDP(User Datagram Protocol)，用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层

也就是说无论应用层交给 UDP 多长的报文，它统统发送，一次发送一个报文

而对接收方，接到后直接去除首部，交给上面的应用层就完成任务

- UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务
- 传输途中出现丢包，UDP 也不负责重发
- 当包的到达顺序出现乱序时，UDP 没有纠正的功能
- 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制，
  即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为

TCP(Transmission Control Protocol)，传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送

可以想象成流水形式的，发送方 TCP 会将数据放入“蓄水池”(缓存区)，等到可以发送的时候就发送不能发送就等着，TCP 会根据当前网络的拥塞状态来确定每个报文段的大小

- TCP 充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有
- 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费
- 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信(主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现)

### 区别

- TCP 是面向连接的协议，建立连接 3 次握手、断开连接 4 次挥手，UDP 是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取
- TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方
- TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个 TCP 报文段传输后，在目的站重新装配。UDP 协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用
- TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信

## TCP 为什么需要三次握手和四次挥手

### 三次握手(Three-way Handshake)

其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包

主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备

- 第一次握手:客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态
- 第二次握手:服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1 作为 ACK 的值，此时服务器处于 SYN_RCVD 的状态
- 第三次握手:客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的 ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

第一次握手：客户端发送网络包，服务端收到了

这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的

第二次握手：服务端发包，客户端收到了

这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常

第三次握手：客户端发包，服务端收到了
这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常，通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了

### 四次挥手（Four-Way Handshake）

目的：确保双方都完成数据传输，并且可以安全地关闭连接。

过程：

第一次挥手（FIN）：

**主动关闭方（客户端）**发送一个带有 FIN 标志的 TCP 段，并设置序列号 seq=u。
目的是告诉接收方：“我已经没有数据要发送了，请准备好关闭连接。”

第二次挥手（ACK）：

**被动关闭方（服务器）**收到 FIN 后，发送一个带有 ACK 标志的 TCP 段，并设置确认号 ack=u+1。
目的是告诉主动关闭方：“我已经收到你的关闭请求，我会继续处理剩余的数据。”

第三次挥手（FIN）：

**被动关闭方（服务器）**处理完剩余的数据后，发送一个带有 FIN 标志的 TCP 段，并设置序列号 seq=v，确认号 ack=u+1
目的是告诉主动关闭方：“我也已经没有数据要发送了，请关闭连接。”

第四次挥手（ACK）：

**主动关闭方（客户端）**收到 FIN 后，发送一个带有 ACK 标志的 TCP 段，并设置确认号 ack=v+1
目的是告诉被动关闭方：“我已经收到你的关闭请求，连接可以关闭了。”

原因：
确保数据完整传输：四次挥手确保双方都已经完成了数据传输，并且可以安全地关闭连接
防止数据丢失：四次挥手过程中，双方都需要确认对方的关闭请求，确保数据不会丢失
通过三次握手和四次挥手，TCP 协议能够确保连接的可靠建立和安全关闭，从而保证数据传输的完整性

## HTTP1.0/1.1/2.0 的区别

- HTTP1.0:

  - 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接

- HTTP1.1:

  - 引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用
  - 在同一个 TCP 连接里面，客户端可以同时发送多个请求
  - 虽然允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
  - 新增了一些请求方法
  - 新增了一些请求头和响应头

- HTTP2.0:

  - 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
  - 采用二进制格式而非文本格式
  - 使用报头压缩，降低开销
  - 服务器推送

### http 1.1 与 http 2 的区别

- 多路复用 (Multiplexing)
  - HTTP 1.1: 每个 TCP 连接只能处理一个请求。如果一个请求阻塞了，其他请求也会被阻塞（称为“队头阻塞”问题）
  - HTTP 2: 支持多路复用，可以在同一个 TCP 连接上并发处理多个请求。这样可以显著减少延迟
- 二进制协议
  - HTTP 1.1: 基于文本的协议，消息头和消息体都是纯文本格式
  - HTTP 2: 采用二进制格式，提高了解析效率和传输速度
- 头部压缩 (Header Compression)
  - HTTP 1.1: 使用 HTTP 缓存和 Cookie 等机制，但没有专门的头部压缩机制，每次请求都需要传输完整的头部信息
  - HTTP 2: 使用 HPACK 算法进行头部压缩，减少了每次请求的开销
- 服务器推送 (Server Push)
  - HTTP 1.1: 不支持服务器主动推送资源给客户端
  - HTTP 2: 支持服务器推送，即服务器可以在客户端请求之前就推送相关资源，减少延迟
- 优先级 (Priority)
  - HTTP 1.1: 没有明确的优先级机制
  - HTTP 2: 支持优先级机制，可以根据重要性来调度请求，优化资源加载顺序
- 错误处理 (Error Handling)
  - HTTP 1.1: 错误处理较为简单，通常只有简单的状态码
  - HTTP 2: 提供了更详细的错误处理机制，包括错误码和错误消息，便于调试和诊断问题
- TLS 1.2 作为默认加密协议
  - HTTP 1.1: 可以使用 SSL/TLS 加密，但没有强制要求
  - HTTP 2: 强烈建议使用 TLS 1.2 或更高版本，提供了更强的安全保障
- 性能改进
  - HTTP 1.1: 性能受到队头阻塞等问题的影响
  - HTTP 2: 通过多路复用、头部压缩等机制显著提升了性能

## 地址栏输入 URL 敲下回车后发生了什么 / 浏览器从输入 url 到加载完成都发生了什么

- URL 解析
- DNS 查询
- TCP 连接
- HTTP 请求
- 响应请求
- 页面渲染

### 页面渲染

当浏览器接收到服务器响应的资源后，首先会对资源进行解析:

- 解析 HTML，构建 DOM 树
- 解析 CSS，生成 CSS 规则树
- 合并 DOM 树和 CSS 规则，生成 render 树
- 布局 render 树(Layout/reflow)，负责各元素尺寸、位置的计算
- 绘制 render 树(paint)，绘制页面像素信息
- 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成(composite)，显示在屏幕上
