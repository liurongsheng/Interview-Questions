# http 问题

## 理解 UDP 和 TCP？区别？应用场景？

UDP(User Datagram Protocol)，用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层

也就是说无论应用层交给 UDP 多长的报文，它统统发送，一次发送一个报文

而对接收方，接到后直接去除首部，交给上面的应用层就完成任务

- UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务
- 传输途中出现丢包，UDP 也不负责重发
- 当包的到达顺序出现乱序时，UDP 没有纠正的功能
- 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制，
  即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为

TCP(Transmission Control Protocol)，传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送

可以想象成流水形式的，发送方 TCP 会将数据放入“蓄水池”(缓存区)，等到可以发送的时候就发送不能发送就等着，TCP 会根据当前网络的拥塞状态来确定每个报文段的大小

- TCP 充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有
- 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费
- 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信(主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现)

### 区别

- TCP 是面向连接的协议，建立连接 3 次握手、断开连接 4 次挥手，UDP 是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取
- TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方
- TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个 TCP 报文段传输后，在目的站重新装配。UDP 协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用
- TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信

## TCP 为什么需要三次握手和四次挥手

### 三次握手(Three-way Handshake)

其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包

主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1 作为 ACK 的值，此时服务器处于 SYN_RCVD 的状态
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的 ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

其中第二次握手，服务端会在自己的 SYN 报文中指定它的初始序列号（ISN），第三次握手的 ACK 值，就是服务器的 ISN+1

第一次握手：客户端发送网络包，服务端收到了

证明客户端的发送能力是正常的

第二次握手：服务端发包，客户端收到了

证明服务端的接收能力、发送能力是正常的。不能确认客户端的接收能力是否正常

第三次握手：客户端发包，服务端收到了

证明客户端的接收能力正常

#### TCP 能不能只要两次握手

现实因为网络问题，会有已经失效的客户端连接请求报文到达服务器。比如客户端重连的请求

如果只有两次握手，此时客户端忽略服务器端发来的确认，也不发送数据，造成不必要的错误和网络资源的浪费

如果有三次握手，失效的报文到服务端，服务器端确认并向客户端发送报文，但此时客户端不会发出确认，由于客户端没有确认，由于服务器端没有接收到确认，就会知道客户端没有请求连接

### 四次挥手（Four-Way Handshake）

目的：确保双方都完成数据传输，并且可以安全地关闭连接。

过程：

第一次挥手（FIN）：

**主动关闭方（客户端）**发送一个带有 FIN 标志的 TCP 段，并设置序列号 seq=u。
目的是告诉接收方：“我已经没有数据要发送了，请准备好关闭连接。”

第二次挥手（ACK）：

**被动关闭方（服务器）**收到 FIN 后，发送一个带有 ACK 标志的 TCP 段，并设置确认号 ack=u+1。
目的是告诉主动关闭方：“我已经收到你的关闭请求，我会继续处理剩余的数据。”

第三次挥手（FIN）：

**被动关闭方（服务器）**处理完剩余的数据后，发送一个带有 FIN 标志的 TCP 段，并设置序列号 seq=v，确认号 ack=u+1
目的是告诉主动关闭方：“我也已经没有数据要发送了，请关闭连接。”

第四次挥手（ACK）：

**主动关闭方（客户端）**收到 FIN 后，发送一个带有 ACK 标志的 TCP 段，并设置确认号 ack=v+1
目的是告诉被动关闭方：“我已经收到你的关闭请求，连接可以关闭了。”

原因：
确保数据完整传输：四次挥手确保双方都已经完成了数据传输，并且可以安全地关闭连接
防止数据丢失：四次挥手过程中，双方都需要确认对方的关闭请求，确保数据不会丢失
通过三次握手和四次挥手，TCP 协议能够确保连接的可靠建立和安全关闭，从而保证数据传输的完整性

## HTTP1.0/1.1/2.0 的区别

- HTTP1.0:

  - 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接

- HTTP1.1:

  - 引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用
  - 在同一个 TCP 连接里面，客户端可以同时发送多个请求
  - 虽然允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
  - 新增了一些请求方法
  - 新增了一些请求头和响应头

- HTTP2.0:

  - 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
  - 采用二进制格式而非文本格式
  - 使用报头压缩，降低开销
  - 服务器推送

- HTTP3.0: 基于 QUIC（快速 UDP 互联网连接）协议构建的。QUIC 最初是由 Google 设计的，旨在减少延迟并提高 Web 性能。HTTP/3 解决了 HTTP/2 中存在的一些问题

  - 减少连接建立时间
  - 多路复用无阻塞
  - 快速丢包恢复和拥塞控制
  - 连接迁移

HTTP/2 基于 TCP 和 TLS，需要多个往返时间（RTT）来完成握手。HTTP/3 使用 QUIC 协议，它将加密和传输合并为一个过程，允许在 一个 RTT 完成连接建立，在最佳情况下甚至可以在零 RTT 中恢复会话

HTTP/2 虽然支持多路复用，但 TCP 层的队头阻塞问题仍然存在。HTTP/3 通过 QUIC 改进的多路复用能力，在 QUIC 中由于是基于数据报的 UDP，独立的流可以在其他流发生丢包时继续传输，解决了 TCP 的队头阻塞问题

QUIC 实现了更快速的丢包恢复机制。TCP 需要等待一段时间来确认丢包，而 QUIC 可以利用更精细的确认机制来迅速响应丢包情况，并相应调整拥塞控制策略

QUIC 支持连接迁移，允许客户端在网络环境变化（如从 Wi-Fi 切换到移动网络）时，保持现有的连接状态。在 HTTP/2 这种情况通常会导致连接中断和需要重新建连

### http 1.1 与 http 2 的区别

- 多路复用 (Multiplexing)
  - HTTP 1.1: 每个 TCP 连接只能处理一个请求。如果一个请求阻塞了，其他请求也会被阻塞（称为“队头阻塞”问题）
  - HTTP 2: 支持多路复用，可以在同一个 TCP 连接上并发处理多个请求。这样可以显著减少延迟
- 二进制协议
  - HTTP 1.1: 基于文本的协议，消息头和消息体都是纯文本格式
  - HTTP 2: 采用二进制格式，提高了解析效率和传输速度
- 头部压缩 (Header Compression)
  - HTTP 1.1: 使用 HTTP 缓存和 Cookie 等机制，但没有专门的头部压缩机制，每次请求都需要传输完整的头部信息
  - HTTP 2: 使用 HPACK 算法进行头部压缩，减少了每次请求的开销
- 服务器推送 (Server Push)
  - HTTP 1.1: 不支持服务器主动推送资源给客户端
  - HTTP 2: 支持服务器推送，即服务器可以在客户端请求之前就推送相关资源，减少延迟
- 优先级 (Priority)
  - HTTP 1.1: 没有明确的优先级机制
  - HTTP 2: 支持优先级机制，可以根据重要性来调度请求，优化资源加载顺序
- 错误处理 (Error Handling)
  - HTTP 1.1: 错误处理较为简单，通常只有简单的状态码
  - HTTP 2: 提供了更详细的错误处理机制，包括错误码和错误消息，便于调试和诊断问题
- TLS 1.2 作为默认加密协议
  - HTTP 1.1: 可以使用 SSL/TLS 加密，但没有强制要求
  - HTTP 2: 强烈建议使用 TLS 1.2 或更高版本，提供了更强的安全保障
- 性能改进
  - HTTP 1.1: 性能受到队头阻塞等问题的影响
  - HTTP 2: 通过多路复用、头部压缩等机制显著提升了性能

## 地址栏输入 URL 敲下回车后发生了什么 / 浏览器从输入 url 到加载完成都发生了什么

- URL 解析
- DNS 查询
- TCP 连接
- HTTP 请求
- 响应请求
- 页面渲染

- 浏览器地址栏输入 url
- 浏览器会先查看浏览器缓存--系统缓存--路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步
- 域名解析（DNS）获取相应的 ip
- 浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手
- 握手成功，浏览器向服务器发送 http 请求，请求数据包
- 服务器请求数据，将数据返回到浏览器
- 浏览器接收响应，读取页面内容，解析 html 源码，生成 DOM 树
- 解析 css 样式、浏览器渲染，js 交互

### 页面渲染

当浏览器接收到服务器响应的资源后，首先会对资源进行解析:

- 解析 HTML，构建 DOM 树
- 解析 CSS，生成 CSS 规则树
- 合并 DOM 树和 CSS 规则，生成 render 树
- 布局 render 树(Layout/reflow)，负责各元素尺寸、位置的计算
- 绘制 render 树(paint)，绘制页面像素信息
- 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成(composite)，显示在屏幕上

## http 状态码

- 1xx：1 开头的是信息状态码
- 2xx：2 开头的是请求成功
- 3xx：3 开头的是重定向
- 4xx：4 开头的是客户端错误
- 5xx：5 开头的是服务器错误

### 1 开头：（被接受，需要继续处理）

这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束
由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应

- 100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝
  客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
- 101 服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议
- 102 (代表处理将被继续执行) 由 WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行

### 2 开头 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受

- 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页
- 201 （已创建） 请求成功并且服务器创建了新的资源
- 202 （已接受） 服务器已接受请求，但尚未处理
- 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源
- 204 （无内容） 服务器成功处理了请求，但没有返回任何内容
- 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容
- 206 （部分内容） 服务器成功处理了部分 GET 请求
- 207 (代表之后的消息体将是一个 XML 消息)，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码

### 3 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向

- 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
- 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
- 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
- 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
- 304 （未修改）自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容
- 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
- 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

### 4 开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理

- 400 （错误请求） 服务器不理解请求的语法
- 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应
- 403 （禁止） 服务器拒绝请求
- 404 （未找到） 服务器找不到请求的网页
- 405 （方法禁用） 禁用请求中指定的方法
- 406 （不接受） 无法使用请求的内容特性响应请求的网页
- 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
- 408 （请求超时） 服务器等候请求时发生超时
- 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息
- 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应
- 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求
- 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件
- 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力
- 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理
- 415 （不支持的媒体类型） 请求的格式不受请求页面的支持
- 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码
- 417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求

### 5 开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误

这些错误可能是服务器本身的错误，而不是请求出错

- 500 （服务器内部错误） 服务器遇到错误，无法完成请求
- 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
- 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应
- 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态
- 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求
- 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本
