# 软件设计原则

6 大程序设计原则和 23 种设计模式

## 单一职责原则 (Single Responsibility Principle)

- 永远不应该有多于一个原因来改变某个类
- 理解：对于一个类而言，应该仅有一个引起它变化的原因
- 应用：如果一个类拥有了两种职责，那就可以将这个类分成两个类

单一职责原则有什么好处：

- 类的复杂性降低，实现什么职责都有清晰明确的定义
- 可读性提高，复杂性降低，那当然可读性提高了
- 可维护性提高，可读性提高，那当然更容易维护了
- 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助

ps：接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化

单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异

## 里氏替换原则 (Liskov Substitution Principle)

- 理解：父类一定能够被子类替换

定义：所有引用基类的地方必须能透明地使用其子类的对象

通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类
还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应
定义中包含的四层含义：

    - 子类必须完全实现父类的方法
    - 子类可以有自己的个性
    - 覆盖或实现父类的方法时输入参数可以被放大,
       如果父类的输入参数类型大于子类的输入参数类型，会出现父类存在的地方，子类未必会存在，
       因为一旦把子类作为参数传入，调用者很可能进入子类的方法范畴
    - 覆写或实现父类的方法时输出结果可以被缩小
       父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，
       那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类

## 开放封闭原则 (Open Closed Principle)

- 软件实体扩展应该是开放的，但对于修改应该是封闭的
- 理解：对扩展开放，对修改封闭。**可以去扩展类，但不要去修改类**
- 应用：当需求有改动，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码

定义：软件实体应该对扩展开放，对修改关闭
其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化
软件实体：项目或软件产品中按照一定的逻辑规则划分的模块、抽象和类、方法变化的三种类型：

- 逻辑变化
  只变化一个逻辑，而不涉及其他模块，比如原有的一个算法是 a*b+c，现在需要修改为 a*b\*c，
  可以通过修改原有类中的方法的方式来完成，前提条件是所有依赖或关联类都按照相同的逻辑处理

- 子模块变化
  一个模块变化，会对其他的模块产生影响，特别是一个低层次的模块变化必然引起高层模块的变化，
  因此在通过扩展完成变化时，高层次的模块修改是必然的

- 可见视图变化
  可见视图是提供给客户使用的界面，如 JSP 程序、Swing 界面等，该部分的变化一般会引起连锁反应（特别
  是在国内做项目，做欧美的外包项目一般不会影响太大）。可以通过扩展来完成变化，这要看我们原有的设计是否灵活

## 最少知识原则

- 只与你最直接的对象交流
- 理解：低耦合，高内聚
- 应用：做系统设计时，尽量减小依赖关系

## 接口隔离原则 (Interface Segregation Principle)

- 一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口
- 理解：不要对外暴露没有实际意义的接口。用户不应该依赖它不需要的接口
- 应用：当需要对外暴露接口时，如果是非必要对外提供，尽量删除

接口分为两种：

- 实例接口（Object Interface）：Java 中的类也是一种接口
- 类接口（Class Interface）： Java 中经常使用 Interface 关键字定义的接口

隔离：建立单一接口，不要建立臃肿庞大的接口；即接口要尽量细化，同时接口中的方法要尽量少
接口隔离原则与单一职责原则的不同：接口隔离原则与单一职责的审视角度是不相同的，
单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少

## 依赖倒置原则 (Dependence Inversion Principle)

- 高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象
- 理解：应该面向接口编程，不应该面向实现类编程

原始定义：

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象
- 抽象不应该依赖细节（实现类）
- 细节应该依赖抽象

依赖倒置原则在 java 语言中的体现：

- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的
- 接口或抽象类不依赖于实现类
- 实现类依赖接口或抽象类

依赖的三种写法：

- 构造函数传递依赖对象（构造函数注入）
- Setter 方法传递依赖对象（setter 依赖注入）
- 接口声明依赖对象（接口注入）

使用原则：
依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，
我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以：

- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
- 变量的表面类型尽量是接口或者是抽象类
- 任何类都不应该从具体类派生（只要不超过两层的继承是可以忍受的）
- 尽量不要复写基类的方法
- 结合里氏替换原则使用

## 总结

将以上六大原则的英文首字母拼在一起就是 SOLID(稳定的 )，所以也称之为 SOLID 原则

只有满足了这六大原则，才能设计出稳定的软件架构

组合/聚合复用原则

- 当要扩展类的功能时，优先考虑使用组合，而不是继承
- 该原则在 23 种经典设计模式中频繁使用
- 如:代理模式、装饰模式、适配器模式等

无环依赖原则

- 当 A 模块依赖于 B 模块，B 模块依赖于 C 模块，C 依赖于 A 模块此时将出现循环依赖
- 在设计中避免该问题，可通过引入“中介者模式”解决
