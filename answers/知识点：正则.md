# 知识点：正则

## 三大元素
`var reg = /^\d$/g`
** 修饰符 元字符 量词 **

### 修饰符
g - global 全局匹配（只要有匹配成功的结果一直匹配直到没有为止）
i - ignoreCase 忽略大小写
m - multiline 多行匹配

### 元字符
元字符其中分为特殊元字符和普通元字符，普通元字符就是列入数组，字母等元素
常用特殊元字符如下： 

1. `\ 转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义的字符转变为普通字符）`
1. `. 除了\n（换行符）以外的任意字符`
1. `\d 匹配一个0~9之间的数字`
1. `\D 匹配一个非0~9之间的数字（大写与小写字母组合正好是相反含义）`
1. `\w 匹配一个0~9或字母或_之间的一个字符`
1. `\s 匹配一个任意空白字符`
1. `\b 匹配一个边界符`
1. `x|y 匹配x或者y中的一个`
1. `[a-z] 匹配a-z中的任意一个字符`
1. `[^a-z] 匹配非a-z中的任意一个字符`
1. `[xyz] 匹配x或y或z中的一个字符`
1. `[^xyz] 和上方相反`
1. `() 整的小分组，匹配一个小分组（可以理解为大正则中的一个小正则）`
1. `^ 以某一个元字符开始`
1. `$ 以某一个元字符结束`
1. `?: 只匹配不捕获`
1. `?= 正向肯定预查`
1. `?! 正向否定预查`

### 量词
量词主要的作用是用来描述元字符出现的次数

1. `? 出现零到一次` //可以不出现，也可以支出现一次（单次可选）
1. `* 出现零到多次` //可以出现无数次，也可以不出现（任意次数均可）
1. `+ 让前面的元字符出现一到多次` //可以出现无数次，但至少要出现一次（至少一次）
1. `{n} 出现n次`
1. `{n,} 出现n到多次`
1. `{n,m} 出现n到m次`

---

## 使用示例

### 元字符的使用

1. 开始元字符 ^
匹配启示位置的元字符，例：var reg = /^2/; 表示开头必须是2，如果开始元字符放在[]里面，[^]表示非中括号种情况
`/^2/.test('2d') //true`
`/^2/.test('3d') //false`
`/^[^2]/.test('2d') //false` 表示不能以2开头
`/^[^2]/.test('3d') //true`  

2. 结束元字符 $
匹配结束位置的元字符，例：var reg = /2$/; 表示结尾必须是2。
`/2$/.test('d2') //false`
`/2$/.test('d2') //true`

3. 转义字符 \
将特殊元字符转换为普通字符，例：var reg = /^2.3$/ 正常理解为匹配开头为2 结束为3中间是.的正则，但是在这里面.属于特殊元字符，
意义是除了\n（换行符）以外的任意字符，所以不论是2.3或者2+3或者2s.3等等，只要不是\n都匹配成功，
所以为了这种需求就用到了转义字符\ 如下： var reg = /^2\.3$/ 将特殊元字符.转义为真正的.元素，再次匹配只有2.3才能匹配成功
`/^2.3$/.test('2\n3') //false`
`/^2.3$/.test('2\b3') //true`
`/^2\.3$/.test('2\b3') //false`
`/^2\.3$/.test('2.3') //true`
如下思考：
```javascript
/^\d$/.test('3') //true  只能是一个数字  
/^\\d$/.test('\\d') //true 只能是`\\d`
/^\\\d$/.test('\\3') //true 只能是两个反斜杠和一个数字
/^\\\\d$/.test('\\\\d') //true 只能是`\\\\d`
/^\\\\\d$/.test('\\\\3') //true 只能是四个反斜杠和一个数字
/^\\$/.test('\\') //true
```
/^\d$/表示0-9之间的数字 所以0-9都能匹配成功

/^\\d$/出现两个\ 不论是0-9 d \d都匹配失败，只有\\d才匹配成功，原因在于第一个转义字符把第二个\转义为普通\，此时第一个\也表示普通字符，所以只有匹配到\\d才生效

/^\\\d$/出现三个\，此时大家一定会认为\\\d才是正确答案，非也，此时的正确答案是\\[0-9]意思是\和0-9中任意一个数字，原因在于第一个\将第二个转义，
所以变为\\ \d分为了两部分，\\为普通字符，而\d表示一个0~9之间的数字，所以正确答案是\\[0-9]

/^\\\\d$/出现四个\ 很多同学会认为正确答案一定是\\\[0-9], 很可惜，正确的是\\\\d，原因是当第一个把第二个转义为普通字符时，第三个又把第四个转义为普通字符，所以最后匹配为\\\\d

看到这里相信有一部分小伙伴已经晕了，虽然在工作我们不会玩这种操作，但是要深刻理解转义字符，在正则中如果你直接写 var reg = /^$/会报错，因为正则中不能单独一个\出现，
因为他是一个特殊元字符，需要写至少两个\, 例如： var reg = /^\\$/ 正确的匹配结果为'\\'，所以牢记两个\代表真正的\ 。

4. 或者元字符 x|y

这个元字符很好理解就是匹配x或者匹配y，没有什么难度，举个小例子：

`/2|3/.test('2') //true`
`/2|3/.test('3') //true`


5. 小分组 ()

在上面同学们会发现用了()这样的元字符，他主要的特点就是将括号内的正则规则看成一个整体，相当于一个小的独立的正则，主要处理如下例子中的问题
```
var reg = /^18|19$/

`/^18|19$/.test('18') //true`
`/^18|19$/.test('19') //true`
`/^18|19$/.test('181') //true`
`/^18|19$/.test('189') //true`

// 这个例子很多同学能够了解是18或者19开头 但是结尾呢？真的只匹配19么？ 其实并不是
// 正确的匹配除了18 19 还有181和189 这时候小分组就起到了作用如下

var reg = /^(18|19)$/
/^(18|19)$/.test('189') //false
/^(18|19)$/.test('18') //true

// 这里将18或19用()包裹起来，起到小分组的作用
// 这样这个正则只匹配18开头结尾或者19而不是181和189
```
6.分组引用 \n

分组引用的概念就是可以引用大正则中指定的小正则规则，例如：

var reg = /^([a-z])([a-z])\2([a-z])$/
// 符合的字符串：book week http ...​

具体上面的例子理解为\2代表着第二个小正则规则的完全引用，就是和第二个小正则([a-z])一样，可以减少正则的复杂度和处理多次重复规则

`/^([a-z])([a-z])\1([a-z])$/.test('abac') //true` 
`/([a-z])([1-7])\2/.test('a12') //false`
`/([a-z])([1-7])\2/.test('a11') //true`

7.匹配字符 []
```
[xyz]、[^xyz]、[a-z]、[^a-z]

var reg = /^[a-zA-Z0-9_]$/
// 这个正则和等价于\w 就是匹配一个0~9或字母或_之间的一个字符
[a-z]：匹配a-z中的任意一个字符 
[^a-z]：和上面的相反 匹配任意一个非a-z的字符
[xyz]：匹配x或者y或者z中的一个字符 
[^xyz]：匹配除了xyz以外的任意字符
// 有一个重点补充，在[]中的特殊元字符一般都代表本身含义，如下
/^[.?+&]$/.test('.') //true 代表着匹配[.?+&]中的某个元素
```

8.边界符 \b

匹配一个单词边界，也就是指单词和空格间的位置（边界主要是单词的左右两边） 例如：
```
/er\b/.test('aer') //true
// 可以匹配never中的er，但是不能匹配verb中的er
/\b\w+\b/g.test('my blog is www.ngaiwe.com')
// 能匹配字母数字和下划线与单词边界 'my blog is www.ngaiwe.com'
// 能匹配 'my'、'blog'、'is'、'www'、'ngaiwe'、'com'

/\b\w+\b/.test('[%^]2') //true
/\b\w+\b/.test('[%^2]') //true 有疑问？
```

9.只匹配不捕获 ?:

下面举一个例子，但是涉及到捕获内容，如果同学们不太明白，可以先跳过此处，看完下面捕获，再返回来看
```
var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/g
var str = '110105199001220613'
console.log(reg.exec(str))
// 打印结果为 "110105199001220613", "110105", "1990", "01", "22", "1", "3"

var reg = /^(\d{6})(?:\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/g
// 打印结果为 "110105199001220613", "110105", "01", "22", "1", "3"
// 会将第二个小分组只匹配，不捕获
```

10.正向肯定预查 ?=

用于匹配一个元素后面是的元素是否符合相应规则，但是并不消耗这个规则
```
/windows(?=95|98|NT|2000)/.test('windows2000') //true
/windows(?=95|98|NT|2000)/.test('windowsxp') //false

/windows(?=95|98|NT|2000)/.exec('windows2000') //["windows", index: 0, input: "windows2000", groups: undefined]
/windows(?=95|98|NT|2000)/.exec('windowsxp') //null
// 能捕获到str1 并且捕获结果是windows 并没有将2000也同时捕获
// 说明正向预查只负责匹配相应规则

/win(?=d)dows/.test('windows') //true
/win(d)dows/.test('windows') //false
// 原因是正向预查只负责匹配，不消耗字符，也就是并不会匹配为里面规则的字符
// /win(?=d)dows/ 相当于匹配windows并且符合win后面第一个出现的是d
// /win(d)dows/ 相当于匹配winddows
```

11.正想否定预查 ?!

和正向肯定预查相反，匹配不符合规则的正则

## 正则的两种创建方式

一种是字面量创建，另一种是构造函数创建

1.字面量创建

var reg = /\d+/img

2.构造函数创建

var reg = new RegExp('\\d+', 'img') 第一个参数是元字符并且\d这种特殊字符在这里面是普通字符，所以需要用\转义为特殊字符，第二个参数是修饰符

这两种的用途有区别，一般需要动态创建正则元字符采用构造函数创建，因为里面元字符是字符串拼接，常规固定写死正则采用字面量创建，例子如下：

var stringMode = 'string'
var reg = new RegExp(`^\\[object ${stringMode}\\]$`)
console.log(reg.toString())

## 正则原型方法

RegExp.prototype
正则原型对象上一共就三个方法,exec、test和toString

### RegExp.prototype:exec 实现正则捕获的方法
exec该方法主要应用于捕获组而设计，实参是要匹配的字符串

### 捕获原理

1.在捕获的时候先验证当前字符串和正则是否匹配，不匹配返回null（没有捕获到任何内容）
2.如果匹配从字符串最左边开始，向右查找到匹配内容，并把匹配的内容返回

### 捕获结果
1.结果是一个数组
2.第一项0 是当前本次大正则中匹配的结果
3.index是匹配到的结果在字符串中的索引位置
4.input当前正则操作的原始字符串
5.如果大正则中有分组()，获取的数组中从第二项开始都是每个小分组的捕获结果

`/\d+/.exec('liu23liu45liu') //["23", index: 3, input: "liu23liu45liu", groups: undefined]`

//1. 先去验证当前字符串和正则是否匹配 如果不匹配返回的结果是null
//2. 如果匹配 从字符串最左边开始 向右查找找到匹配的内容 并且把匹配的内容返回
// exec捕获到结果的格式：
//=>获取的结果是一个数组 
//=>数组中的第一项是当前本次大正则在字符串中匹配到的结果
//=>index:记录了当前本次捕获到结果的起始索引
//=>input:当前正则操作的原始字符串
//=>如果当前正则中有分组 获取的数组中 从第二项开始都是小分组本次匹配到的结果（通过exec可以把分组中的内容捕获到）
//==>执行一次exec只能把符合正则规则条件中的第一个内容捕获到 如果还有其他符合规则的 需要再次执行exec才有可能捕获到


特性：懒惰性

正则捕获存在懒惰性，在上面exec中，执行一次exec只捕获到第一个符合规则的内容，第二次执行exec也是捕获到第一个内容，后面的内容不论执行多少次都无法捕获到

解决方法是在正则的末尾加修饰符g（全局匹配）

正则本身有一个属性 lastIndex 下一次正则在字符串中匹配查找的开始索引，默认值是0，从字符串第一个位置开始查找，
由此可见，当执行完exec后lastIndex并没有变，并且就算手动修改lastIndex也不会起作用，浏览器不识别

加上了修饰符g就解决了这个问题，因为每一次exec之后，浏览器默认会修改lastIndex，下一次从上一次结束的位置开始查找，所以可以得到后面内容

/^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/g.exec('110105199001220613')
//(7) ["110105199001220613", "110105", "1990", "01", "22", "1", "3", index: 0, input: "110105199001220613", groups: undefined]


### RegExp.prototype:test 该方法主要应用于正则匹配，当然也可以用在捕获上面

从字符串左侧开始匹配，匹配到符合正则规则的字符，返回true，否则返回false，同样的test在修饰符g下也会修改lastIndex的值

运用test实现捕获
var reg = /\{([a-z]+)\}/g
var str = 'my name is {weiran}. I am from {china}'
var result = []
while (reg.test(str)) {
	result.push(RegExp.$1)
}
console.log(result)
// ['weiran', 'china']

当test匹配到结尾或者匹配不到时，返回false，成功则向数组添加当前小分组匹配第一个元素内容
在RegExp的constructor中存在$1-$9，他们的具体指的是当前本次匹配小分组第一到第九捕获的内容

### RegExp.prototype:toString 就是将正则表达式转化为字符串


## 字符串正则方法

1.match

同样是捕获的方法，如图所示：

当加了修饰符g，返回的是大正则匹配结果组成的数组，不加修饰符g则返回大正则和每个小分组返回结果组成的数组，跟上面我们手写的myExec一样，
其实原理就是我们上面写的方法，如果想在加了修饰符g的时候返回结果和没加一样，所以在直接用match方法就能将匹配内容全部捕获到。
但是他也有局限性，就想上面说的在加了修饰符g的时候，会忽略小分组捕获内容，只捕获大正则捕获内容，解决办法就向上面myExec一样，
将arrs[0]改为arrs，在每次匹配到结果时，将每个小分组也保存下来。

2.replace

主要运用在替换，其中两个参数，第一个为要替换的字符串或者正则，第二个是替换内容或一个返回函数，具体操作如下：

var str = 'my name is {weiran}, my blog is {ngaiwe}'
var reg = /\{([a-z]+)\}/
str = str.replace(reg, '123')
console.log(str)
// 打印出 my name is 123, my blog is {ngaiwe}
// 同学们会发现和exec的懒惰性很相似，不加修饰符g 只匹配第一个lastIndex没有改变

var reg = /\{([a-z]+)\}/g
// 打印出 my name is 123, my blog is 123
并且replace不会修改原始字符串


var str = 'my name is {weiran}, my blog is {ngaiwe}'
var reg = /\{([a-z]+)\}/g
str = str.replace(reg, function () {
	console.log(arguments)
})
// 打印出当前匹配的小分组，如果函数中没有return出替换值，则返回undefined

3.split

按照正则方式可以拆分成数组，具体例子如下：

var str = 'weiRanNgaiWe'
var reg = /[A-Z]/
console.log(str.split(reg))
// ["wei", "an", "gai", "e"]按照大写拆分成数组

4.search

类似于indexOf,返回匹配元素的起始位置，如果没有返回-1，不支持修饰符g

var str = 'ngaiwe@126.com'
var reg = /\d+/
console.log(str.search(reg))
// 返回 7

## 实例

1.身份证号码

举个身份证的例子： 110105199109214237
由此分析前6位是数字地区区号组成，然后四位是年，两位月，两位日和四位随机，倒数第二位单数男性，双数女性，最后一位可能是大写X,所以根据这个规则的正则是

var str = '110105199109214237'
var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/
console.log(reg.exec(str))
// ["110105199109214237", "110105", "1991", "09", "21", "3", "7", index: 0, input: "110105199109214237", groups: undefined]

2.邮箱

举个邮箱的例子：weiran@vipkid.com.cn
由此分析：
1.@前面可能是数字、字母、下划线、-、.
2.-和.不能相连在一起
/^\w+((-|\w+)|(.\w+))*/ 开头一定是数字，字母或下划线组成，后面的内容可能是-与数字字母下划线 或者.和数字字母下划线组成的0到多个字符
3.@后面部分
首先一定是数字字母组成的多位字符
然后可能存在是.组成的邮箱后缀或者链接前方字符的.和-
最后肯定是.组成的邮箱后缀

var reg = /^\w+((-|\w+)|(\.\w+))*@[a-zA-Z0-9]+((\.|-)[a-zA-Z0-9]+)*\.[a-zA-Z0-9]+$/
var str = 'weiran@vipkid.com.cn'
console.log(reg.test(str))
// true

3.URL截取

举个截取url参数的例子：
http://www.ngaiwe.com/page/index.html?name=weiran&age=27&sex=0#develpoment
我们想要的是参数转化键值对和哈希值{name: 'weiran',age: 27, sex: 0, HASH: 'develpoment'}
由此分析：
需要分为两部分捕获，首先第一次捕获?后面的参数，第二次捕获#后面的hash值
首先匹配第一个，他的规则是匹配等号两边所以是/()=()/，并且匹配的是非?&=#的特殊字符，将他们保存在obj对象中
其次匹配hash，方法和第一个类似只是匹配#后面的部分

String.prototype.myQueryURLParameter = function myQueryURLParameter () {
	var obj = {}
	this.replace(/([^?&=#]+)=([^?&=#]+)/g, function () {
		obj[arguments[1]] = arguments[2]
	})
	this.replace(/#([^?&=#]+)/g, function () {
		obj['HASH'] = arguments[1]
	})
	return obj
}


https://blog.csdn.net/So_______/article/details/78979270