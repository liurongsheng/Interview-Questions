# CSRF跨站请求伪造

CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。

简单来理解CSRF就是攻击者盗用了你的身份，以你的名义发送恶意请求。

CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......
造成的问题包括：个人隐私泄露以及财产安全。

<img src="img/CSRF跨站请求伪造.jpg" title="CSRF跨站请求伪造">

关键步骤：

* 登录受信任网站A，并在本地生成Cookie。

* 在不登出A的情况下，访问危险网站B。

所以如果登录一个网站后出现后面几种情况就有可能产生CSRF：

1.不再打开一个tab页面并访问另外的网站；

2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。
（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了......）

3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。

### 任何防御
 
CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。
 
服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。

* 检查 Origin

当我们收到一个请求时，关于这个请求的来源有两个地方的信息对我们来说是有用的。
一个是 Origin header，另一个是 Referer header。
你可以检查他们中的一个或者两个的值来判定对于你的网站来说他们是不是来自一个不同的域。
如果这个请求是跨域的，那么你把它丢掉就可以了。
Origin 和 Referer header 会在浏览器端做一些保护措施来阻止被纂改，但是这并不总是有效的。

* token

表单中嵌入一个随机的token。当真正的用户提交表单的时，你就会收到表单的随机 token，
这样你就可以通过之前嵌入的那个随机 token 来校验了。
在 CSRF 攻击场景中，攻击者永远都不可能拿到这个值甚至在攻击者可以请求到页面的情况也无法拿到，
因为同源策略（SOP）会阻止攻击者从包含 token 的响应中读取内容。

* Same-Site Cookies

找到你原来的 cookie ：
Set-Cookie: sess=abc123; path=/

添加 SameSite 这个属性。
Set-Cookie: sess=abc123; path=/; SameSite

在 cookie 上启用这个属性将会告诉浏览器给予这个 cookie 确切的保护。
你可以通过 Strict 和 Lax 这两种模式来启用这个保护，具体用哪种模式取决于你想要的严格程度。
如果在你的 cookie 设置中没有指定模式的话默认将会使用 Strict 模式，但是如果你想的话你可以明确的指定是 Strict 还是 Lax。
  
    SameSite=Strict
    SameSite=Lax

